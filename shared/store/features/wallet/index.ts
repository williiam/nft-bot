/* eslint-disable @typescript-eslint/no-empty-function */
// redux
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

// library
import { ethers } from 'ethers'

// imports
import { getWalletList, addWallet, deleteWallet } from './actions';

declare type walletData = {
  address: any,
  signature: any
}

export type walletState = {
  walletList: [walletData] | [];
  loading: boolean;
  error: boolean;
  pending: boolean;
};

const initialState: walletState = {
  walletList: [],
  loading: false,
  error: false,
  pending: false

};

export const walletSlice = createSlice({
  name: 'walletData',
  initialState,
  reducers: {
    setPending: (state,action:PayloadAction<[walletData]>) => {
      state.pending = action.payload.pending;
    },
    setWalletList: (state,action:PayloadAction<[walletData]>) => {
      console.log('action :', action);
      state.walletList = action.payload.walletList;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  // Since this is an API call we have 3 possible outcomes: pending, fulfilled and rejected. We have made allocations for all 3 outcomes.
  // Doing this is good practice as we can tap into the status of the API call and give our users an idea of what's happening in the background.
  extraReducers: (builder) => {
    builder
      // getWallet
      .addCase(getWalletList.pending, (state) => {
      })
      .addCase(getWalletList.fulfilled, (state, { payload }) => {
        // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
        state.pending = false;
      })
      .addCase(getWalletList.rejected, (state) => {
        state.pending = false;
        // state.error = true;
      })
      // addWallet
      .addCase(addWallet.pending, (state) => {
      })
      .addCase(addWallet.fulfilled, (state) => {
        state.pending = false;
      })
      .addCase(addWallet.rejected, (state) => {
        state.pending = false;
        // state.error = true;
      })
      // deleteWallet
      .addCase(deleteWallet.pending, (state) => {
      })
      .addCase(deleteWallet.fulfilled, (state) => {
        state.pending = false;
      })
      .addCase(deleteWallet.rejected, (state) => {
        state.pending = false;
        // state.error = true;
      });
  },
});

export default walletSlice.reducer;

export const { setWalletList, setPending } = walletSlice.actions